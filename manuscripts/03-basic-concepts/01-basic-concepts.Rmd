class: inverse, middle, center

# Basic concepts illustrated using a two-level factor (pp.3--8)

---

class: inverse, middle
<!-- class: inverse, middle, split-50 -->

## 1要因2水準の実験で，応答変数の平均値を比較

1. シミュレーション用データを作成
2. シミュレーションの結果を図や表で確認
3. シミュレーション用データに対し線形モデルを構築
    - とりあえず線形モデルを作るとどうなるか試す
4. Default contrast coding: treatment contrasts
5. Defining hypotheses
6. Sum contrast
7. Cell means parameterization

---

::::: block

### シミュレーション用データを作成

- [`mixedDesign()`](http://read.psych.uni-potsdam.de/attachments/article/188/mixedDesign.v0.6.3.R)を使う
- 1要因2水準
    1. F1: 0.8秒
    1. F2: 0.4秒
- 実験参加者数10人
  - 被験者間計画 (between-subject design)
  - 実験参加者は，F1の条件だけ，またはF2の条件だけに接する
    1. F1: 5人
    1. F2: 5人

:::::

---

<!--
https://stackoverflow.com/questions/67750561/vertically-scrollable-code-with-rstudio-and-xaringan
-->

`r chunk_reveal("simdat", left_assign=TRUE)`

<!--
#### the number of between-subject factors
-->

```{r simdat, include = FALSE}
simdat <- mixedDesign(
  #### 被験者間計画での水準数 ####
  B = 2,
  #### 被験者内計画での水準数 ####
  W = NULL,
  #### 被験者間計画での1水準あたりの実験参加者数 ####
  #### 実験参加者総数は，`B * n` ####
  n = 5,
  #### 水準ごとの応答変数の平均を示した行列 ####
  #### 各行に水準ごとの応答変数の平均を入れる ####
  M = matrix(
    c(0.8, 0.4),
    nrow = 2,
    ncol = 1,
    byrow = FALSE
  ),
  #### 要因の標準偏差 ####
  SD = 0.20,
  #### 「1試行1データ」の整然データでデータフレームを作成 ####
  long = TRUE
) |>
  rename(F = B_A) |>
  mutate(
    F = fct_recode(
      F,
      F1 = "A1",
      F2 = "A2"
    )
  )

str(simdat)
```

---

::::: block

### シミュレーションの結果を図や表で確認

- 1要因2水準
    1. F1: 0.8秒（標準偏差0.2秒）
    1. F2: 0.4秒（標準偏差0.2秒）

:::::

---

`r chunk_reveal("fig-simdat")`

```{r fig-simdat, include = FALSE}
simdat |>
  group_by(F) |>
  summarise(
    N = length(DV),
    M = mean(DV),
    SD = sd(DV),
    SE = SD / sqrt(N)
  ) |>
  ungroup() |>
  (
    \(d){
      qplot(
        x = F, y = M,
        group = 1,
        data = d,
        geom = c("point", "line")
      )
    }
  )() +
  geom_errorbar(
    aes(
      max = M + SE,
      min = M - SE
    ),
    width = 0
  ) +
  labs(
    y = "Mean DV",
    x = "Factor F"
  )
```

---

`r chunk_reveal("tab-simdat")`

```{r tab-simdat, include = FALSE}
simdat |>
  group_by(F) |>
  summarise(
    N = length(DV),
    M = mean(DV),
    SD = sd(DV),
    SE = SD / sqrt(N)
  ) |>
  ungroup() |>
  kable(
    digits = 2,
    col.names = c(
      'Levels of Factor',
      'N. of data points',
      'Mean RT',
      'Std. Dev.',
      'Std. Err.'
    )
  )
```

---

::: columns

:::: pull-left

::::: block

### シミュレーション用データに対し線形モデルを構築

- 水準間で応答変数の平均が有意に異なるか，線形モデルで確認

```{r}
#| lm-simdat,
#| include = TRUE

m_F <- lm(DV ~ F, simdat)
```

- 切片 (intercept, `r m_F |> tidy() |> filter(term == "(Intercept)") |> pull(estimate)`)
  - F1の下での応答変数の平均 $\widehat{{\mu}_{\text{F1}}}$
- 傾き (intercept, `r m_F |> tidy() |> filter(term == "FF2") |> pull(estimate)`)
  - F2の下での応答変数の平均とF1の下での応答変数の平均の差 $\widehat{{\mu}_{\text{F2}}} - \widehat{{\mu}_{\text{F1}}}$


:::::

::::

:::: pull-right

```{r}
#| tab-lm-simdat2,
#| ref.label=c('tab-lm-simdat', 'fig-simdat'),
#| echo = FALSE,
#| eval = TRUE
```

::::

:::

---

::: columns

:::: pull-left

::::: block

### シミュレーション用データに対し線形モデルを構築

- 95%信頼区間 (95% Confidence Interval)
  - 平均値 $\pm `r qnorm(0.975) |> round(3)` \times \text{標準誤差 (Standanrd Error)}$
  - 「100回実験して95回は真値を含むような区間」
- $t$ 値
  - この $t$ 値は，自由度が $(\text{（その水準から得られたデータポイント数）}-1) \times 2$ の $t$ 分布に従う
  - この $t$ 分布の両側2.5%の範囲にあれば，有意
  - $(5-1) \times 2 = `r (5-1) * 2`$ なので，今回の $t$ 値は， $t(`r (5-1) * 2`)$ に従う
  - $t(`r (5-1) * 2`)$ の両側2.5%の範囲は， $t \leq `r qt(0.025, df = (5-1) * 2) |> abs() |> round(2)`, `r qt(0.975, df = (5-1) * 2) |> abs() |> round(2)` \leq t$
  - $t$ 値が上記区間に入っていれば，有意

:::::

::::

:::: pull-right

```{r}
#| tab-lm-simdat,
#| ref.label=c('tab-lm-simdat', 'fig-simdat'),
#| echo = FALSE,
#| eval = TRUE
```

::::

:::

---

`r chunk_reveal("tab-lm-simdat")`

```{r tab-lm-simdat, include = FALSE}
m_F |>
  tidy(
    conf.int = TRUE,
    conf.level = 0.95
  ) |>
  mutate(
    `95% CI` = paste0(
      "[",
      conf.low |> round(3),
      ", ",
      conf.high |> round(3),
      "]"
    )
  ) |>
  relocate(
    `95% CI`, .after = estimate
  ) |>
  dplyr::select(
    -c(
      std.error,
      conf.low,
      conf.high
    )
  ) |>
  kable(
    digits = 2,
    escape = FALSE,
    col.names = c(
      'Predictor',
      'Estimate',
      '95% CI',
      '$t$-value',
      '$p$-value'
    )
  )
```

---

::: columns

:::: pull-left

::::: block

### Default contrast coding: treatment contrasts

- 切片 (intercept, `r m_F |> tidy() |> filter(term == "(Intercept)") |> pull(estimate)`)
  - F1の下での応答変数の平均 $\widehat{{\mu}_{\text{F1}}}$
- 傾き (intercept, `r m_F |> tidy() |> filter(term == "FF2") |> pull(estimate)`)
  - F2の下での応答変数の平均とF1の下での応答変数の平均の差 $\widehat{{\mu}_{\text{F2}}} - \widehat{{\mu}_{\text{F1}}}$

なぜ，切片と傾きがこの値になるのか？？

--

$\because$ デフォルトでは，Rは，名義尺度に[treatment contrast](#treatment-contrast)を適用するため

:::::

::::

:::: pull-right


```{r}
#| lm-simdat-2,
#| ref.label=c('lm-simdat'),
#| echo = TRUE,
#| eval = FALSE
```
```{r}
#| fig-simdat-2,
#| ref.label=c('fig-simdat'),
#| echo = FALSE,
#| eval = TRUE
```

::::

:::

---

`r chunk_reveal("treatment-simdat", title = "### Treatment contrastsとその意味", display_type = c("code", "output", "md"), md = "$$x = \\begin{cases} 0 & \\text{F1 のとき} \\\\ 1 & \\text{F2 のとき} \\end{cases}$$")`

```{r treatment-simdat, include = FALSE}
contrasts(simdat$F)
```

---

::: columns

:::: pull-left

::::: block

### Default contrast coding: treatment contrasts

Rがデフォルトで名義尺度に適用する対比

$$x =
\begin{cases}
0 & \text{F1 のとき} \\
1 & \text{F2 のとき}
\end{cases}$$

```{r}
#| lm-simdat-2,
#| ref.label=c('treatment-simdat'),
#| include = FALSE,
#| echo = FALSE,
#| eval = TRUE,
#| results = "hold"
```

```{r}
#| include = FALSE,
#| echo = FALSE,
#| eval = FALSE,
#| results = "asis"

chunk_reveal("treatment-simdat", display_type = c("md", "code", "output"), md = "$$x = \\begin{cases} 0 & \\text{F1 のとき} \\\\ 1 & \\text{F2 のとき} \\end{cases}$$")
```

$$\therefore \begin{align}\overbrace{y}^{\text{応答変数}} & = \overbrace{{\beta}_0}^{\text{切片}} + \overbrace{{\beta}_1}^{\text{傾き}} x\\
& =
\begin{cases}
{\beta}_0 + {\beta}_1 \times 0 & \text{F1 のとき}\\
{\beta}_0 + {\beta}_1 \times 1 & \text{F2 のとき}
\end{cases}\\
& =
\begin{cases}
{\beta}_0 & \text{F1 のとき}\\
{\beta}_0 + {\beta}_1 & \text{F2 のとき}
\end{cases}\\
& =
\begin{cases}
`r m_F |> tidy() |> filter(term == "(Intercept)") |> pull(estimate)` & \text{F1 のとき}\\
`r m_F |> tidy() |> filter(term == "(Intercept)") |> pull(estimate)` + (`r m_F |> tidy() |> filter(term == "FF2") |> pull(estimate)`) & \text{F2 のとき}
\end{cases}\\
& =
\begin{cases}
`r m_F |> tidy() |> filter(term == "(Intercept)") |> pull(estimate)` & \text{F1 のとき}\\
`r (m_F |> tidy() |> filter(term == "(Intercept)") |> pull(estimate)) + (m_F |> tidy() |> filter(term == "FF2") |> pull(estimate))` & \text{F2 のとき}
\end{cases}\end{align}$$

:::::

::::

:::: pull-right

<!--

$$\begin{align}\overbrace{y}^{\text{応答変数}} & = \overbrace{{\beta}_0}^{\text{切片}} + \overbrace{{\beta}_1}^{\text{傾き}} x\\
& =
\begin{cases}
{\beta}_0 + {\beta}_1 \times 0 & \text{F1 のとき}\\
{\beta}_0 + {\beta}_1 \times 1 & \text{F2 のとき}
\end{cases}\\
& =
\begin{cases}
{\beta}_0 & \text{F1 のとき}\\
{\beta}_0 + {\beta}_1 & \text{F2 のとき}
\end{cases}\end{align}$$

-->

```{r}
#| fig-simdat-2,
#| ref.label=c('fig-simdat'),
#| echo = FALSE,
#| eval = TRUE
```

::::

:::

---

::::: block

### Defining hypotheses

Treatment contrastの下では，

- 傾き ${\beta}_1$
  - 「実験条件の応答変数の平均値」と「統制条件での応答変数の平均値」の差
  - ( ${\mu}_{\text{F2}} - {\mu}_{\text{F1}}$ )
- 切片 ${\beta}_0$
  - 統制条件での応答変数の平均値
  - ( ${\mu}_{\text{F1}}$ )

--

↑切片や傾きの意味を言語化しただけ

--

**切片や傾きを通じて，どのような帰無仮説を棄却しようとしているのか？**

:::::

---

::::: block

#### 傾き ${\beta}_1$ に関する帰無仮説 $H_0$

帰無仮説：傾きが存在しない

--

$H_0: {\beta}_1 = 0$

--

$H_0: {\mu}_{\text{F2}} - {\mu}_{\text{F1}} = 0$

:::::


::::: block

#### 切片 ${\beta}_0$ に関する帰無仮説 $H_0$

帰無仮説：切片が存在しない

--

$H_0: {\beta}_0 = 0$

--

$H_0: {\mu}_{\text{F1}} = 0$

:::::

---

#### 統制条件とする水準を変えるには

- Rは，水準をアルファベット順に読み込み，アルファベット順に数値（0,1）を付与する
- アルファベット順に関係なく，特定の水準を統制条件としたい場合には
  
---

`r chunk_reveal("recode-simdat", left_assign = TRUE, title = "#### 統制条件とする水準を変えるには")`

```{r}
#| recode-simdat,
#| include = FALSE

simdat <- simdat |>
  mutate(
    Fb = fct_relevel(
      F,
      "F2",
      "F1"
    )
  )

contrasts(simdat$Fb)

contrasts(simdat$F)
```

---

::: columns

:::: pull-left

**F2を統制条件にした場合**

```{r}
#| recode-lm-simdat,
#| echo = TRUE,
#| eval = TRUE,
#| include = TRUE

m1_mr <- lm(DV ~ Fb, simdat)
```

```{r tab-recode-lm-simdat, echo = FALSE, eval = TRUE}
m1_mr |>
  tidy(
    conf.int = TRUE,
    conf.level = 0.95
  ) |>
  mutate(
    `95% CI` = paste0(
      "[",
      conf.low |> round(3),
      ", ",
      conf.high |> round(3),
      "]"
    )
  ) |>
  relocate(
    `95% CI`, .after = estimate
  ) |>
  dplyr::select(
    -c(
      std.error,
      conf.low,
      conf.high
    )
  ) |>
  kable(
    digits = 2,
    escape = FALSE,
    col.names = c(
      'Predictor',
      'Estimate',
      '95% CI',
      '$t$-value',
      '$p$-value'
    )
  )
```

$$x =
\begin{cases}
0 & \text{F2 のとき} \\
1 & \text{F1 のとき}
\end{cases}$$

$$\therefore\begin{align}
%\overbrace{y}^{\text{応答変数}} & = \overbrace{{\beta}_0}^{\text{切片}} + \overbrace{{\beta}_1}^{\text{傾き}} x\\
y & = {\beta}_0 + {\beta}_1 x\\
& =
\begin{cases}
{\beta}_0 + {\beta}_1 \times 0 & \text{F2 のとき}\\
{\beta}_0 + {\beta}_1 \times 1 & \text{F1 のとき}
\end{cases}\\
& =
\begin{cases}
`r m1_mr |> tidy() |> filter(term == "(Intercept)") |> pull(estimate)` & \text{F2 のとき}\\
`r m1_mr |> tidy() |> filter(term == "(Intercept)") |> pull(estimate)` + (`r m1_mr |> tidy() |> filter(term == "FbF1") |> pull(estimate)`) & \text{F1 のとき}
\end{cases}\\
& =
\begin{cases}
`r m1_mr |> tidy() |> filter(term == "(Intercept)") |> pull(estimate)` & \text{F2 のとき}\\
`r (m1_mr |> tidy() |> filter(term == "(Intercept)") |> pull(estimate)) + (m1_mr |> tidy() |> filter(term == "FbF1") |> pull(estimate))` & \text{F1 のとき}
\end{cases}\end{align}$$

::::

:::: pull-right

F1が統制条件である場合

```{r}
#| ref.label=c('lm-simdat'),
#| echo = TRUE,
#| eval = FALSE
```

```{r}
#| tab-lm-simdat3,
#| ref.label=c('tab-lm-simdat'),
#| echo = FALSE,
#| eval = TRUE
```

$$x =
\begin{cases}
0 & \text{F1 のとき} \\
1 & \text{F2 のとき}
\end{cases}$$

$$\therefore \begin{align}
%\overbrace{y}^{\text{応答変数}} & = \overbrace{{\beta}_0}^{\text{切片}} + \overbrace{{\beta}_1}^{\text{傾き}} x\\
y & = {\beta}_0 + {\beta}_1 x\\
& =
\begin{cases}
{\beta}_0 + {\beta}_1 \times 0 & \text{F1 のとき}\\
{\beta}_0 + {\beta}_1 \times 1 & \text{F2 のとき}
\end{cases}\\
& =
\begin{cases}
`r m_F |> tidy() |> filter(term == "(Intercept)") |> pull(estimate)` & \text{F1 のとき}\\
`r m_F |> tidy() |> filter(term == "(Intercept)") |> pull(estimate)` + (`r m_F |> tidy() |> filter(term == "FF2") |> pull(estimate)`) & \text{F2 のとき}
\end{cases}\\
& =
\begin{cases}
`r m_F |> tidy() |> filter(term == "(Intercept)") |> pull(estimate)` & \text{F1 のとき}\\
`r (m_F |> tidy() |> filter(term == "(Intercept)") |> pull(estimate)) + (m_F |> tidy() |> filter(term == "FF2") |> pull(estimate))` & \text{F2 のとき}
\end{cases}\end{align}$$

::::

:::

---

::: columns

:::: pull-left

::::: block

**F2を統制条件にした場合**

#### 傾き ${\beta}_1$ に関する帰無仮説 $H_0$

帰無仮説：傾きが存在しない

--

$H_0: {\beta}_1 = 0$

--

$H_0: {\mu}_{\text{F1}} - {\mu}_{\text{F2}} = 0$

:::::


::::: block

#### 切片 ${\beta}_0$ に関する帰無仮説 $H_0$

帰無仮説：切片が存在しない

--

$H_0: {\beta}_0 = 0$

--

$H_0: {\mu}_{\text{F2}} = 0$

:::::

::::

:::: pull-right

::::: block

F1が統制条件である場合

#### 傾き ${\beta}_1$ に関する帰無仮説 $H_0$

帰無仮説：傾きが存在しない

$H_0: {\beta}_1 = 0$

$H_0: {\mu}_{\text{F2}} - {\mu}_{\text{F1}} = 0$

:::::


::::: block

#### 切片 ${\beta}_0$ に関する帰無仮説 $H_0$

帰無仮説：切片が存在しない

$H_0: {\beta}_0 = 0$

$H_0: {\mu}_{\text{F1}} = 0$

:::::

::::

:::

---

<!--
1. Sum contrast
2. Cell means parameterization
-->
