name: orthogonal-contrast

`r chunk_reveal("orthogonal-contrast-coefficient-matrix", left_assign = "TRUE", title = "## Orthogonal contrasts  \n  \n**直交対比**：対比行列の中で，2つの対比（列）を選び，行ごとに掛け算し，その掛け算を足し合わせた時に0になる", display_type = c("code", "output", "md"), md = c("1つの要因につき2水準ずつある要因が2個ある場合の，対比行列を作成  \n  \nこの対比行列は，sum contrast  \n  \n全部で4条件ある", "tibbleデータフレームに変換  \n  \nmatrixオブジェクトに比べ，行や列に対する操作が簡単になる"), widths = c(3, 2, 1))`

```{r}
#| orthogonal-contrast-coefficient-matrix,
#| include = FALSE

Xsum <- cbind(
  F1    = c(1,  1, -1, -1),
  F2    = c(1, -1,  1, -1),
  F1xF2 = c(1, -1, -1,  1)
) |>
  as_tibble()
```

---

`r chunk_reveal("orthogonal-contrast-coefficient", left_assign = "detect", title = "## Orthogonal contrasts  \n  \n**直交対比**：対比行列の中で，2つの対比（列）を選び，行ごとに掛け算し，その掛け算を足し合わせた時に0になる", display_type = c("code", "output", "md"), md = c("**F1**と**F2**を選択し，**sel.cols**というデータフレームにする", "元の対比行列から2列だけ取り出した**sel.cols**", "**sel.cols**に対し，行ごとの処理を実行させる", "- **everything()**でデータフレームの全ての列を選択  \n  \n- 先ほど選択した列に対し，**c_across()**で一括処理を行うよう指定  \n  \n- 列の値同士を掛け合わせる", "掛け合わさった値を全て足すと0になる"), widths = c(3, 2, 1))`

```{r}
#| orthogonal-contrast-coefficient,
#| include = FALSE

sel.cols <- Xsum |> dplyr::select(F1, F2)

sel.cols |>
  rowwise() |>
  summarise(
    everything() |>
      c_across() |>
      prod()
  ) |>
  sum()
```

---

`r chunk_reveal("orthogonal-contrast-coefficient-rotate", left_assign = "detect", break_type = "rotate", title = "## Orthogonal contrasts  \n  \n**直交対比**：対比行列の中で，2つの対比（列）を選び，行ごとに掛け算し，その掛け算を足し合わせた時に0になる", display_type = c("code", "output", "md"), md = c("**F2**と**F1xF2**を選択した場合", "**F1**と**F1xF2**を選択した場合"), widths = c(3, 2, 1))`

```{r}
#| orthogonal-contrast-coefficient-rotate,
#| include = FALSE

sel.cols <- Xsum |> dplyr::select(F2, F1xF2) #ROTATE
sel.cols <- Xsum |> dplyr::select(F1, F1xF2) #ROTATE

sel.cols |>
  rowwise() |>
  summarise(
    everything() |>
      c_across() |>
      prod()
  ) |>
  sum()
```

---

`r chunk_reveal("correlation-orthogonal-contrast-coefficient", left_assign = "detect", title = "## Orthogonal contrasts  \n  \n- 対比行列から2列ずつ選択して計算しなくても，対比行列の直交性は確認できる  \n- **対比行列内の2列に相関がなければよい**  \n  - **F1**と**F2**の相関が0  \n  - **F2**と**F1xF2**の相関が0  \n  - **F1**と**F1xF2**の相関が0\n", display_type = c("code", "output"))`

```{r}
#| correlation-orthogonal-contrast-coefficient,
#| include = FALSE

Xsum |> cor()
```

---

## 1要因複数水準では，Orthogonal contrastsにならない場合もある

- ここまでのOrthogonal contrastsは，複数要因での対比
  - 1つの要因につき2水準ずつある要因が2個ある場合
- **3水準以上ある要因1個の場合には，Orthogonal contrastsにならない場合もある**

---

`r chunk_reveal("multi-level-factor-orthogonality", left_assign = "detect", break_type = "rotate", title = "## 1要因複数水準では，Orthogonal contrastsにならない場合もある", display_type = c("code", "output", "md"), md = c("Sum contrastsを適用  \n  \n**Orthogonal contrastsにならない**", "Repeated contrastsを適用  \n  \n**Orthogonal contrastsにならない**", "Treatment contrastsを適用  \n  \n**Orthogonal contrastsにならない**", "Polynomial contrastsを適用  \n  \nOrthogonal contrastsになる", "Helmert contrastsを適用  \n  \nOrthogonal contrastsになる"), widths = c(3, 2, 1))`

```{r}
#| multi-level-factor-orthogonality,
#| include = FALSE

contr.sum(4) |> cor() |> fractions() #ROTATE
contr.sdif(4) |> cor() |> fractions() #ROTATE
contr.treatment(4) |> cor() |> fractions() #ROTATE
contr.poly(4) |> cor() |> fractions() #ROTATE
contr.helmert(4) |> cor() |> fractions() #ROTATE
```

---

## 直交性が重要である理由

- 逆行列を計算する際，直交する対比は互いに独立に変換される
- 仮説行列が直交しているなら，その仮説行列に一般化逆行列を適用すると，出来上がる対比行列は，単に仮説行列での数値の比率を変えただけのものになる

## 直交性が重要である理由

::: columns

:::: pull-left

### 対比行列を直接作れる場合

- 対比が完全に直交している場合，かつ説明変数の比率が問題にならない場合
- 一般化逆行列を使わずに，対比行列を直接作ることができる

::::

:::: pull-right

### 仮説行列に一般化逆行列を適用して，対比行列を作る必要がある場合

- 説明変数の比率が問題になる場合
- 直交でない対比あるいは中心化されていない対比が含まれる場合

::::

:::
